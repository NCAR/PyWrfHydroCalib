"""
This is a self-contained utility program to generate necessary input parameter
files for the WRF-Hydro calibration workflow. It's assumed the user has
already created a set of domain files with the following:
    fullDom.nc - The high-resolution routing grid file
    geo_em.nc - The geogrid file for the modeling domain
    GWBUCKPARM.nc - The NetCDF version of GWBUCKPARM.TBL

These three parameter files contain parameter values that may or may not
be adjusted during the calibration process. This depends on which model
parameters the user chooses to calibrate. The following two files are also
neccessary for the calibration workflow to function properly:
    soil_properties.nc
    HYDRO_TBL_2D.nc
    
However, these two files are currently not generated by the GIS pre-processing
toolkit. This self-contained program is a means to generate the files 
prior to running the calibration for a basin, or set of basins. 

The following arguments are passed into the program:
    domainDirectory - The directory containing input domain files for the
                      basin to create the new parameter files. This is also 
                      the same directory the new files will be written to.
    tableDirectory - This is the directory containing SOILPARM.TBL, 
                     MPTABLE.TBL, GENPARM.TBL, and HYDRO.TBL global parameter
                     tables, which are necessary for this program to run
                     successfully. 
                  
Author - Logan Karsten
Organization - National Center for Atmospheric Research
               Research Applications Laboratory
Contact - karsten@ucar.edu
"""

import numpy as np
from netCDF4 import Dataset
import pandas as pd
import shutil
import os
import sys
import argparse

def main(argv):
    # Parse user-provided arguments
    parser = argparse.ArgumentParser(description='Utility program to create soil_properties.nc,' + \
             ' and HYDRO_TBL_2D.nc for the calibration workflow')
    parser.add_argument('domainDirectory',metavar='domainDirectory',type=str,nargs='+',
                        help='Directory containing necessary input NetCDF domain files.')
    parser.add_argument('tableDirectory',metavar='tableDirectory',type=str,nargs='+',
                        help='Directory containing input global static table files, ' + \
                        'such as MPTABLE.TBL,etc.')
    args = parser.parse_args()
    
    # Establish program constants
    fillParam = -9999
    soilFillVal = -9999
    
    # Check for existence of directories and expected files.
    if not os.path.isdir(args.domainDirectory[0]):
        errOut(args,'ERROR: ' + args.domainDirectory[0] + ' Not Found.')
    if not os.path.isdir(args.tableDirectory[0]):
        errOut(args,'ERROR: ' + args.tableDirectory[0] + ' Not Found.')
    
    geoFile = args.domainDirectory[0] + '/geo_em.nc'
    soilTbl = args.tableDirectory[0] + '/SOILPARM.TBL'
    mpTbl = args.tableDirectory[0] + '/MPTABLE.TBL'
    genTbl = args.tableDirectory[0] + '/GENPARM.TBL'
    hydroTbl = args.tableDirectory[0] + '/HYDRO.TBL'
    soilPropOut = args.domainDirectory[0] + '/soil_properties.nc'
    hydroTblOut = args.domainDirectory[0] + '/HYDRO_TBL_2D.nc'
    
    if not os.path.isfile(geoFile):
        errOut(args,'ERROR: ' + geoFile + ' Not Found.')
    if not os.path.isfile(soilTbl):
        errOut(args,'ERROR: ' + soilTbl + ' Not Found.')
    if not os.path.isfile(mpTbl):
        errOut(args,'ERROR: ' + mpTbl + ' Not Found.')
    if not os.path.isfile(genTbl):
        errOut(args,'ERROR: ' + genTbl + ' Not Found.')
    if not os.path.isfile(hydroTbl):
        errOut(args,'ERROR: ' + hydroTbl + ' Not Found.')
    if os.path.isfile(soilPropOut):
        errOut(args,'ERROR: ' + soilPropOut + ' Already Exists. Please remove and re-run program')
    if os.path.isfile(hydroTblOut):
        errOut(args,'ERROR: ' + hydroTblOut + ' Already Exists. Please remove and re-run program')
        
    # Establish paths to original copies of the data and temporary files during creation
    #geoOrig = args.domainDirectory[0] + '/geo_em.nc.ORIG'
    soilPropTmp = args.domainDirectory[0] + '/soil_properties_TMP.nc'
    hydroOutTmp = args.domainDirectory[0] + '/HYDRO_TBL_2D_TMP.nc'
    
    # Open the original Geogrid file
    try:
        idGeoOrig = Dataset(geoFile,'r')
    except:
        errOut(args,'ERROR: Unable to open: ' + geoFile)
        
    # Extract dimension sizes
    try:
        nxGeo = idGeoOrig.dimensions['west_east'].size
        nyGeo = idGeoOrig.dimensions['south_north'].size
    except:
        errOut(args,'ERROR: Unable to extract dimension sizes from: ' + geoFile)
        
    # Open and read the SOILPARM.TBL file. We will assume to use the STATSGO parameter
    # values presented. We will assume this based on the soil_cat dimension length
    # in the geogrid file. If it's not 16, we will throw an error assuming there 
    # is another soil classification scheme being used. 
    if idGeoOrig.dimensions['soil_cat'].size != 16:
        errOut(args,'ERROR: geo_em.nc contains a non-STATSGO classification scheme.')
    try:
        soilTblDf = pd.read_csv(soilTbl,sep=',',header=None,skiprows=[0,1,2],nrows=19,
                                names=('solId','BB','DRYSMC','F11','MAXSMC','REFSMC',
                                'SATPSI','SATDK','SATDW','WLTSMC','QTZ','solName'))
    except:
        errOut(args,'ERROR: Unable to read: ' + soilTbl)
        
    # Read in the MPTABLE.TBL. For now, we will only accept use of the USGS land
    # classification. Future iterations of this program will allow for additional
    # classification schemes. 
    if idGeoOrig.MMINLU != 'USGS':
        errOut(args,'ERROR: Only USGS land classification scheme allowed from geo_em.nc')
    try:
        mpTblDf = pd.read_csv(mpTbl,sep=',',header=None,skiprows=43,nrows=99,comment='!')
    except:
        errOut(args,'ERROR: Unable to open: ' + mpTbl)
    # Run some additional formatting to accomodate the nature of the input file.
    try:
        mpTblDf = mpTblDf[pd.notnull(mpTblDf[2])]
        tblTmp = mpTblDf[0].str.split('=',expand=True)
        mpTblDf = mpTblDf.drop([0],axis=1)
        mpTblDf['Name'] = tblTmp[0]
        mpTblDf[0] = tblTmp[1]
        mpTblDf = mpTblDf.drop([27],axis=1)
        mpTblDf = mpTblDf.reset_index()
        # Strip out whitespace
        for i in range(0,len(mpTblDf.Name)):
            mpTblDf.Name[i] = mpTblDf.Name[i].strip()
    except:
        errOut(args,'ERROR: Unable to format input from: ' + mpTbl + ' Please check the table file.')
        
    ## Read in GENPARM.TBL
    try:
        slopeData = pd.read_csv(genTbl,header=None,skiprows=2,nrows=10)
        slopeData = slopeData[0][1]
        refkdt = float(pd.read_csv(genTbl,header=None,skiprows=23,nrows=1)[0][0])
        refdk = float(pd.read_csv(genTbl,header=None,skiprows=21,nrows=1)[0][0])
        genTab = {'SLOPE':slopeData,'REFKDT':refkdt,'REFDK':refdk}
    except:
        errOut(args,'ERROR: Unable to open and extract values from: ' + genTbl)
     
    # Read in the HYDRO.TBL.
    try:
        hydroTblDf = pd.read_csv(hydroTbl,sep=',',header=None,skiprows=32,nrows=19,
                                 names=('SATDK','MAXSMC','REFSMC','WLTSMC','QTZ','solName'))
        sfcRoughDf = pd.read_csv(hydroTbl,sep=',',header=None,skiprows=2,nrows=28,
                                 names=('OV_ROUGH2D','descrip'))
    except:
        errOut(args,'ERROR: Unable to open: ' + hydroTbl)
        
    # Establish dictionaries for all the ouptut variables and their associated units.
    soilOutUnits = {'slope':'m','refkdt':'m','bexp':'m^3/m^3','cwpvt':'m',
                    'dksat':'m^3/m^3','dwsat':'m^3/m^3','hvt':'m','mfsno':'m',
                    'mp':'m','psisat':'m^3/m^3','quartz':'m^3/m^3','refdk':'m',
                    'smcdry':'m^3/m^3','smcmax':'m^3/m^3','smcref':'m^3/m^3',
                    'smcwlt':'m^3/m^3','vcmx25':'m'}
    soilOutDims = {'slope':2,'refkdt':2,'bexp':3,'cwpvt':2,'dksat':3,'dwsat':3,
                   'hvt':2,'mfsno':2,'mp':2,'psisat':3,'quartz':3,'refdk':2,
                   'smcdry':3,'smcmax':3,'smcref':3,'smcwlt':3,'vcmx25':2}
    hydroOutUnits = {'SMCMAX1':'-','SMCREF1':'-','SMCWLT1':'-','OV_ROUGH2D':'-',
                     'LKSAT':'-'}
    
    # Establish a dictionary associating the output variables with the necessary
    # input variables that need to be read in from the geogrid file.
    soilLookupVars = {'slope':'SLOPE','refkdt':'REFKDT','bexp':'BB','cwpvt':'CWPVT',
                      'dksat':'SATDK','dwsat':'SATDW','hvt':'HVT','mfsno':'MFSNO',
                      'mp':'MP','psisat':'SATPSI','quartz':'QTZ','refdk':'REFDK',
                      'smcdry':'DRYSMC','smcmax':'MAXSMC','smcref':'REFSMC',
                      'smcwlt':'WLTSMC','vcmx25':'VCMX25','OV_ROUGH2D':'OV_ROUGH2D'}
    hydroLookupVars = {'SMCMAX1':'smcmax','SMCREF1':'smcref','SMCWLT1':'smcwlt',
                       'OV_ROUGH2D':'OV_ROUGH2D','LKSAT':'dksat'}
    
    # Create soil_properties and HYDRO_TBL_2D.nc files with global atts/dims, but not variables yet.
    try:
        idSoilOut = Dataset(soilPropTmp,'w')
        idSoilOut.createDimension('Time',None)
        idSoilOut.createDimension('x',nxGeo)
        idSoilOut.createDimension('y',nyGeo)
        idSoilOut.createDimension('west_east',nxGeo)
        idSoilOut.createDimension('south_north',nyGeo)
        idSoilOut.createDimension('soil_layers_stag',4)
        for tmpVar in soilOutUnits:
            if soilOutDims[tmpVar] == 2:
                idSoilOut.createVariable(tmpVar,'f4',('Time','south_north','west_east'),
                                         fill_value=fillParam)
            if soilOutDims[tmpVar] == 3:
                idSoilOut.createVariable(tmpVar,'f4',('Time','soil_layers_stag',
                                         'south_north','west_east'),fill_value=fillParam)
            idSoilOut.variables[tmpVar].units = soilOutUnits[tmpVar]
    except:
        errOut(args,'ERROR: Unable to create temporary soil_properties.nc file.')
        
    try:
        idHydroOut = Dataset(hydroOutTmp,'w')
        idHydroOut.createDimension('west_east',nxGeo)
        idHydroOut.createDimension('south_north',nyGeo)
        for tmpVar in hydroOutUnits:
            idHydroOut.createVariable(tmpVar,'f4',('south_north','west_east'),fill_value=fillParam)
            idHydroOut.variables[tmpVar].units = hydroOutUnits[tmpVar]
    except:
        errOut(args,'ERROR: Unable to create temporary HYDRO_TBL_2D.nc file.')
    
    # Extract necessary fields from the geogrid file for calculations and conversions.
    try:
        vegmap = idGeoOrig.variables['LU_INDEX'][0,:,:]
        solmap = idGeoOrig.variables['SCT_DOM'][0,:,:]
        vegWater = idGeoOrig.ISWATER
        soilWater = idGeoOrig.ISOILWATER
        vegUrban = idGeoOrig.ISURBAN
    except:
        errOut(args,'ERROR: Unable to pull necessary input variables from geogrid file.')
    
    solmap[np.where((vegmap != vegWater) & (solmap == soilWater))] = soilFillVal
    solmap[np.where(vegmap == vegWater)] = soilWater
        
    # Translate updated parameter values to the new soil_properties.nc file
    print "Updating soil_properties.nc"
    for param in idSoilOut.variables:
        paramName = soilLookupVars[param]
        print "Processing: " + param
        if paramName in soilTblDf.columns.values:
            # Parameter is in the soil table, map to the categories
            print "Updating: " + paramName
            pnew = idGeoOrig.variables['SCT_DOM'][0,:,:]
            pnew[np.where((vegmap != vegWater) & (pnew == soilWater))] = soilFillVal
            pnew[np.where(vegmap == vegWater)] = soilWater
            # Loop through each soil category
            cntTmp = 0
            for catTmp in soilTblDf.solId:
                pnew[np.where(solmap == int(catTmp))] = float(soilTblDf[paramName][cntTmp])
                cntTmp = cntTmp + 1
            # Write output to NetCDF
            for i in range(0,soilOutDims[param]+1):
                idSoilOut.variables[param][0,i,:,:] = pnew
        elif len(np.where(mpTblDf.Name == paramName)[0]) == 1:
            # Parameter is in the table, map to the categories. 
            print "Updating: " + paramName
            indexTmp = np.where(mpTblDf.Name == paramName)[0][0]
            pnew = idGeoOrig.variables['LU_INDEX'][0,:,:]
            for catTmp in range(0,len(mpTblDf.columns.values)-2):
                pnew[np.where(vegmap == int(catTmp+1))] = float(mpTblDf[catTmp][indexTmp])
            # Write output to NetCDF
            idSoilOut.variables[param][0,:,:] = pnew
        elif paramName in genTab:
            # Parameter is in the general parameter table
            idSoilOut.variables[param][0,:,:] = genTab[paramName]
            
    # Close the soil_properties.nc file
    idSoilOut.close()
        
    # Translate updated parameter values to the new HYDRO_TBL_2D.nc file
    print "Updating HYDRO_2D_TBL.nc"
    for param in idHydroOut.variables:
        paramName = hydroLookupVars[param]
        print "Processing: " + param
        if soilLookupVars[hydroLookupVars[param]] in soilTblDf.columns.values:
            print "Updating HYDRO soil parameters: " + paramName
            pnew = idGeoOrig.variables['SCT_DOM'][0,:,:]
            pnew[np.where((vegmap != vegWater) & (pnew == soilWater))] = soilFillVal
            pnew[np.where(vegmap == vegWater)] = soilWater
            # Loop through each soil category
            cntTmp = 0
            for catTmp in soilTblDf.solId:
                pnew[np.where(solmap == int(catTmp))] = float(soilTblDf[soilLookupVars[paramName]][cntTmp])
                cntTmp = cntTmp + 1
            # Manually make some changes to urban cells to match hydro code.
            if param == 'SMCMAX1':
                pnew[np.where((vegmap == vegUrban) & (solmap != soilWater))] = 0.45
            if param == 'SMCREF1':
                pnew[np.where((vegmap == vegUrban) & (solmap != soilWater))] = 0.42
            if param == 'SMCWLT1':
                pnew[np.where((vegmap == vegUrban) & (solmap != soilWater))] = 0.40
            # Write to an output NetCDF file
            idHydroOut.variables[param][:,:] = pnew
        elif paramName in sfcRoughDf:
            print "Updating OV_ROUGH2D"
            pnew = idGeoOrig.variables['LU_INDEX'][0,:,:]
            pnew[np.where(vegmap == soilWater)] = vegWater
            # Loop through each vegetation category
            for catTmp in range(0,len(sfcRoughDf.descrip)):
                pnew[np.where(pnew == int(catTmp+1))] = float(sfcRoughDf.OV_ROUGH2D[catTmp])
            # Write output to NetCDF
            idHydroOut.variables[param][:,:] = pnew
            
    # Close the HYDRO_2D_TBL.nc file
    idHydroOut.close()
    
    # Close the original geogrid file
    try:
        idGeoOrig.close()
    except:
        errOut(args,'ERROR: Unable to close: ' + geoFile)
        
    # Move temporary soil_properties and HYDRO_2D_TBL into final spots.
    try:
        shutil.move(soilPropTmp,soilPropOut)
    except:
        errOut(args,'ERROR: Unable to move: ' + soilPropTmp + ' to final location')
    
    try:
        shutil.move(hydroOutTmp,hydroTblOut)
    except:
        errOut(args,'ERROR: Unable to move: ' + hydroOutTmp + ' to final location')

def errOut(args,message):
    """
    Generic function to convey an error message to the user and cleanup
    old files that need to be deleted.
    """
    
    # Print error message to screen for the user
    print(message)
    print('Cleaning Up Residual Files')
    
    geoOrig = args.domainDirectory[0] + '/geo_em.nc.ORIG'
    geoTmp = args.domainDirectory[0] + '/geo_em_TMP.nc'
    soilPropTmp = args.domainDirectory[0] + '/soil_properties_TMP.nc'
    hydroOutTmp = args.domainDirectory[0] + '/HYDRO_TBL_2D_TMP.nc'
    soilPropOut = args.domainDirectory[0] + '/soil_properties.nc'
    hydroTblOut = args.domainDirectory[0] + '/HYDRO_TBL_2D.nc'
    
    if os.path.isfile(soilPropTmp):
        os.remove(soilPropTmp)
    if os.path.isfile(hydroOutTmp):
        os.remove(hydroOutTmp)
    if os.path.isfile(geoOrig):
        os.remove(geoOrig)
    if os.path.isfile(geoTmp):
        os.remove(geoTmp)
    if os.path.isfile(soilPropOut):
        os.remove(soilPropOut)
    if os.path.isfile(hydroTblOut):
        os.remove(hydroTblOut)
        
    # Exit out of the program
    sys.exit(1)
    
if __name__ == "__main__":
    main(sys.argv[1:])